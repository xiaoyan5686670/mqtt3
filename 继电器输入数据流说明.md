# 继电器输入数据流说明

## 完整数据流程

```
MQTT消息 → 后端解析 → 数据库存储 → API查询 → 前端显示
```

---

## 1. MQTT 消息示例

设备通过 MQTT 发送 JSON 格式的消息到订阅的主题（如 `iot/device_001`）：

### 示例1：错误拼写（历史遗留）
```json
{
  "air_temperature_1": 25.3,
  "air_humidity_1": 60.5,
  "realy_in_status": "ON"
}
```

### 示例2：正确拼写（推荐）
```json
{
  "air_temperature_1": 25.3,
  "air_humidity_1": 60.5,
  "relay_in_status": 1
}
```

**注意**：
- `realy_in_status` 是错误拼写（少了一个 'l'），但系统保留向后兼容
- 值可以是字符串（`"ON"`/`"OFF"`）或数字（`1`/`0`）

---

## 2. 后端解析 (`backend/services/mqtt_service.py`)

### 2.1 接收消息
```python
def on_message(self, client, userdata, msg):
    """消息接收回调"""
    payload = msg.payload.decode()  # 获取 JSON 字符串
    self.process_sensor_data(payload, msg.topic)
```

### 2.2 解析 JSON
```python
def parse_and_save_sensor_data(self, device_id: int, payload: str, json_parse_config: str = None):
    """解析并保存传感器数据"""
    # 尝试作为 JSON 解析
    data = json.loads(payload)  # 解析为字典
    # data = {
    #     "air_temperature_1": 25.3,
    #     "air_humidity_1": 60.5,
    #     "realy_in_status": "ON"
    # }
```

### 2.3 处理每个字段
```python
for key, value in data.items():
    # 当 key = "realy_in_status" 或 "relay_in_status" 时
    key_lower = key.lower()  # "realy_in_status"
    
    # 检测是否为继电器输入类型
    if key_lower in ['realy_in_status', 'relay_in_status']:
        # 如果值是字符串 "ON"，转换为数字 1
        if isinstance(value, str):
            value_lower = value.lower().strip()
            if value_lower in ['on', 'open', 'true', '1', 'active', 'enabled']:
                processed_value = 1
            elif value_lower in ['off', 'close', 'false', '0', 'inactive', 'disabled']:
                processed_value = 0
        
        # 设置显示名称
        display_name = "继电器输入"
        
        # 保存到数据库
        self.save_sensor_data(device_id, key, processed_value, unit="", display_name)
```

---

## 3. 数据库存储

### 3.1 数据库表结构

#### sensor_configs 表（传感器配置）
```sql
CREATE TABLE sensor_configs (
    id INTEGER PRIMARY KEY,
    device_id INTEGER,           -- 设备ID
    type VARCHAR,                -- 传感器类型: "realy_in_status" 或 "relay_in_status"
    display_name VARCHAR,        -- 显示名称: "继电器输入"
    unit VARCHAR,                -- 单位: ""
    min_value FLOAT,             -- 最小值: 0
    max_value FLOAT,             -- 最大值: 100
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

#### sensor_data 表（传感器数据）
```sql
CREATE TABLE sensor_data (
    id INTEGER PRIMARY KEY,
    sensor_config_id INTEGER,    -- 关联 sensor_configs.id
    value FLOAT,                 -- 值: 1 (ON) 或 0 (OFF)
    timestamp TIMESTAMP,         -- 时间戳
    alert_status VARCHAR         -- 告警状态: "normal"
);
```

### 3.2 存储示例

假设设备ID为 `1`，接收到的消息为：
```json
{"realy_in_status": "ON"}
```

**sensor_configs 表**（首次创建或更新）：
| id | device_id | type | display_name | unit | min_value | max_value |
|----|-----------|------|--------------|------|-----------|-----------|
| 10 | 1 | realy_in_status | 继电器输入 | "" | 0 | 100 |

**sensor_data 表**（每次接收都插入新记录）：
| id | sensor_config_id | value | timestamp | alert_status |
|----|------------------|-------|-----------|--------------|
| 100 | 10 | 1.0 | 2026-01-21 10:30:00 | normal |

---

## 4. API 查询 (`/api/sensors/latest`)

### 4.1 前端请求
```javascript
const sensorsResponse = await axios.get('/api/sensors/latest')
const allSensors = sensorsResponse.data
```

### 4.2 后端查询逻辑
```python
def get_latest_sensors(db: Session, limit: int = 50) -> List[dict]:
    """获取最新的传感器数据"""
    # JOIN 查询，合并配置和数据
    results = db.query(SensorDataModel, SensorConfigModel).join(
        SensorConfigModel,
        SensorDataModel.sensor_config_id == SensorConfigModel.id
    ).order_by(desc(SensorDataModel.timestamp)).limit(limit).all()
    
    return [_merge_config_and_data(config, data) for data, config in results]
```

### 4.3 返回的 JSON 数据
```json
[
  {
    "id": 100,
    "device_id": 1,
    "type": "realy_in_status",        // ← 原始 JSON 的 key
    "display_name": "继电器输入",        // ← 后端设置的显示名称
    "unit": "",
    "min_value": 0.0,
    "max_value": 100.0,
    "value": 1.0,                     // ← 转换后的数值（1=ON, 0=OFF）
    "timestamp": "2026-01-21T10:30:00",
    "alert_status": "normal"
  },
  {
    "id": 101,
    "device_id": 1,
    "type": "air_temperature_1",
    "display_name": "温度1",
    "unit": "°C",
    "value": 25.3,
    ...
  },
  ...
]
```

**关键字段说明**：
- `type`: 传感器类型，就是 MQTT JSON 消息中的 **原始键名**
  - 例如：`"realy_in_status"` 或 `"relay_in_status"`
  - 这个值用于前端识别和查找传感器
- `value`: 转换后的数值，`1` 表示 ON，`0` 表示 OFF
- `display_name`: 用户友好的显示名称（"继电器输入"）

---

## 5. 前端显示 (`frontend/src/views/Dashboard.vue`)

### 5.1 获取传感器数据
```javascript
const fetchDevicesWithSensors = async () => {
  // 1. 获取所有传感器数据
  const sensorsResponse = await axios.get('/api/sensors/latest')
  const allSensors = sensorsResponse.data  // 包含所有设备的所有传感器
  
  // 2. 按设备ID分组
  const sensorMap = new Map()
  allSensors.forEach(s => {
    if (!sensorMap.has(s.device_id)) {
      sensorMap.set(s.device_id, [])
    }
    sensorMap.get(s.device_id).push(s)
  })
  
  // 3. 为每个设备关联传感器
  devicesWithSensors.value = devices.value.map(device => {
    const sensors = sensorMap.get(device.id) || []
    return { device, sensors, isOnline: ... }
  })
}
```

### 5.2 提取继电器输入的值
```javascript
// 从传感器数组中只查找 realy_in_status（实时上报）
const getRelayInStatusValue = (sensors) => {
  if (!sensors) return 0
  
  // 只查找 realy_in_status（实时数据，时效性高）
  const sensor = sensors.find(s => s.type === 'realy_in_status')
  
  // 返回值：1=ON, 0=OFF
  return sensor ? (sensor.value || 0) : 0
}
```

**查找逻辑**：
1. 遍历 `sensors` 数组（每个设备的传感器列表）
2. **只查找** `type` 字段为 `"realy_in_status"` 的传感器对象（实时数据）
3. 取出 `value` 字段（1 或 0）

**为什么不查找 `relay_in_status`？**
- `realy_in_status` 是实时上报的，时效性高
- `relay_in_status` 是10秒上报的，时效性低
- 为了确保用户看到的是最新状态，只显示实时数据

### 5.3 显示在界面上
```vue
<div 
  class="relay-in-status-indicator mb-2"
  :title="'继电器输入状态（只读）: ' + (getRelayInStatusValue(deviceData.sensors) > 0 ? 'ON（有输入）' : 'OFF（无输入）')"
>
  <div class="status-label">继电器输入</div>
  <div 
    class="status-icon"
    :class="getRelayInStatusValue(deviceData.sensors) > 0 ? 'status-on' : 'status-off'"
  >
    <i class="fas fa-plug"></i>
    <span class="status-text">
      {{ getRelayInStatusValue(deviceData.sensors) > 0 ? 'ON' : 'OFF' }}
    </span>
  </div>
</div>
```

**显示逻辑**：
- 如果 `value > 0`（即 `1`），显示绿色背景，文字 "ON"
- 如果 `value <= 0`（即 `0`），显示灰色背景，文字 "OFF"

---

## 6. 数据流总结

| 阶段 | 数据格式 | 示例 |
|-----|---------|------|
| **MQTT消息** | JSON字符串 | `{"realy_in_status": "ON"}` |
| **后端解析** | Python字典 | `{"realy_in_status": "ON"}` → 转换 → `processed_value = 1` |
| **数据库存储** | 关系型数据 | `sensor_configs.type = "realy_in_status"`, `sensor_data.value = 1.0` |
| **API返回** | JSON对象 | `{"type": "realy_in_status", "value": 1.0, "display_name": "继电器输入"}` |
| **前端处理** | JavaScript对象 | `sensor.type === 'realy_in_status' && sensor.value === 1` |
| **界面显示** | HTML/CSS | 绿色背景 + "ON" 文字 |

---

## 7. 关键要点

### ✅ 继电器输入的值来源
**继电器输入的值来自于 MQTT JSON 消息中的 `realy_in_status` 或 `relay_in_status` 字段。**

1. **字段名称**：设备发送的 JSON 键名（`realy_in_status` 或 `relay_in_status`）
2. **字段值**：可以是字符串（`"ON"`/`"OFF"`）或数字（`1`/`0`）
3. **存储方式**：
   - `sensor_configs.type` 保存原始字段名（如 `"realy_in_status"`）
   - `sensor_data.value` 保存转换后的数值（`1.0` 或 `0.0`）
4. **前端查找**：通过 `sensor.type` 字段匹配 `"realy_in_status"` 或 `"relay_in_status"`

### ✅ 为什么只使用 `realy_in_status`（错误拼写）
- **错误拼写**：`realy_in_status`（历史遗留，少了一个 'l'）- **实时上报，时效性高**
- **正确拼写**：`relay_in_status`（标准拼写）- **10秒上报，时效性低**
- **前端策略**：前端**只显示** `realy_in_status` 的值，确保显示的是最新的实时数据
- **后端兼容**：后端仍然接收并存储两种拼写，但前端只取实时数据

### ✅ 值的转换规则
字符串值自动转换为数字：
- `"ON"`, `"on"`, `"1"`, `"true"`, `"active"`, `"enabled"` → `1`
- `"OFF"`, `"off"`, `"0"`, `"false"`, `"inactive"`, `"disabled"` → `0`

### ✅ 显示逻辑
- `value > 0` → 显示 "ON"（绿色背景）
- `value <= 0` → 显示 "OFF"（灰色背景）

---

## 8. 完整示例

### 设备发送消息
```bash
# 设备通过 MQTT 发送消息到主题 iot/device_001
Topic: iot/device_001
Payload: {"air_temperature_1": 25.3, "realy_in_status": "ON"}
```

### 后端处理
```python
# 解析 JSON
data = {"air_temperature_1": 25.3, "realy_in_status": "ON"}

# 遍历字段
for key, value in data.items():
    # 当处理 realy_in_status 时
    if key == "realy_in_status":
        processed_value = 1  # "ON" 转换为 1
        display_name = "继电器输入"
        # 保存到数据库
        save_sensor_data(device_id=1, sensor_type="realy_in_status", 
                        value=1.0, unit="", display_name="继电器输入")
```

### 前端显示
```javascript
// API 返回的数据（可能包含两种拼写）
const sensors = [
  { type: "realy_in_status", value: 1.0, display_name: "继电器输入" },      // 实时数据
  { type: "relay_in_status", value: 0.0, display_name: "继电器输入" }       // 10秒前的数据
]

// 提取值（只取 realy_in_status，忽略 relay_in_status）
const value = getRelayInStatusValue(sensors)  // 返回 1（来自 realy_in_status）

// 显示
// value > 0 → 显示 "ON" + 绿色背景（显示的是实时状态）
```

---

## 9. 调试建议

如果继电器输入没有正确显示，可以：

1. **检查 MQTT 消息**：确认设备发送的 JSON 中包含 `realy_in_status` 字段（实时数据）
   ```json
   {"realy_in_status": "ON"}  // ✅ 正确
   {"relay_in_status": 1}     // ❌ 前端不会显示此字段（时效性低）
   ```

2. **检查数据库**：
   ```sql
   -- 检查配置表
   SELECT * FROM sensor_configs WHERE type = 'realy_in_status';
   
   -- 检查最新数据
   SELECT sd.*, sc.type, sc.display_name 
   FROM sensor_data sd
   JOIN sensor_configs sc ON sd.sensor_config_id = sc.id
   WHERE sc.type = 'realy_in_status'
   ORDER BY sd.timestamp DESC 
   LIMIT 10;
   ```

3. **检查 API 返回**：在浏览器开发者工具中查看 `/api/sensors/latest` 的返回数据
   - 确认是否包含 `"type": "realy_in_status"` 的对象
   - 检查 `value` 字段是否为 1 或 0

4. **检查前端查找**：在控制台打印 `sensors` 数组
   ```javascript
   console.log('所有传感器:', sensors)
   const relay = sensors.find(s => s.type === 'realy_in_status')
   console.log('继电器输入:', relay)
   ```

5. **检查数据时效性**：
   - 如果看到 `relay_in_status` 但没有 `realy_in_status`，说明设备没有实时上报
   - 检查设备配置，确保启用了 `realy_in_status` 的实时上报功能
