# 多租户功能实现建议

## 一、当前系统状态分析

### 1.1 已实现的功能
- ✅ **用户模型**：已有用户表，支持管理员和普通用户
- ✅ **设备隔离**：设备表已有 `user_id` 字段，已实现基本的用户级设备隔离
- ✅ **权限控制**：API层面已有基本的权限检查（管理员可访问所有，普通用户只能访问自己的）

### 1.2 需要改进的部分
- ❌ **MQTT配置**：目前只有管理员可以创建，没有用户隔离
- ❌ **主题配置**：目前只有管理员可以创建，没有用户隔离
- ❌ **MQTT连接**：系统使用全局单一MQTT连接，所有用户共享
- ❌ **主题订阅**：所有用户共享同一个订阅列表，无法隔离

## 二、多租户架构设计

### 2.1 核心设计原则

1. **数据隔离**：每个用户只能看到和管理自己的资源
2. **资源独立**：每个用户拥有独立的MQTT配置和主题配置
3. **连接隔离**：每个用户拥有独立的MQTT连接（或使用连接池管理）
4. **主题命名规范**：使用用户ID作为主题前缀，避免冲突
5. **管理员特权**：管理员可以查看和管理所有用户的资源

### 2.2 数据模型改造

#### 2.2.1 MQTT配置模型 (`MQTTConfigModel`)
需要添加字段：
```python
user_id = Column(Integer, ForeignKey("users.id"), nullable=True)  # 所属用户ID
# 注意：nullable=True 是为了兼容现有的管理员创建的全局配置
```

#### 2.2.2 主题配置模型 (`TopicConfigModel`)
需要添加字段：
```python
user_id = Column(Integer, ForeignKey("users.id"), nullable=True)  # 所属用户ID
```

#### 2.2.3 设备模型 (`DeviceModel`)
✅ 已有 `user_id` 字段，无需修改

### 2.3 MQTT连接管理策略

#### 方案A：每个用户独立连接（推荐用于小规模）
- **优点**：完全隔离，易于管理
- **缺点**：连接数多，资源消耗大
- **适用场景**：用户数量较少（<100）

#### 方案B：连接池 + 用户标识（推荐用于大规模）
- **优点**：资源利用率高，可扩展性强
- **缺点**：需要管理连接复用和用户标识
- **适用场景**：用户数量较多（>100）

#### 方案C：共享连接 + 主题前缀隔离（最简单）
- **优点**：实现简单，资源消耗最小
- **缺点**：所有用户共享一个连接，安全性较低
- **适用场景**：内部使用，信任度高的场景

**建议**：根据实际用户规模选择方案A或B，如果用户数<50，建议使用方案A。

### 2.4 主题命名规范

为了确保不同用户的主题不冲突，建议使用以下命名规范：

```
用户级主题格式：user/{user_id}/device/{device_name}/...
```

示例：
- 用户1的设备 "pc001" 的传感器数据：`user/1/device/pc001/sensor`
- 用户1的设备 "pc001" 的控制命令：`user/1/device/pc001/control`
- 用户2的设备 "pc002" 的传感器数据：`user/2/device/pc002/sensor`

**迁移策略**：
- 新设备：自动使用新格式
- 旧设备：保持兼容，但建议迁移到新格式

## 三、实现步骤

### 3.1 数据库迁移

#### 步骤1：为MQTT配置表添加user_id字段
```python
# 创建迁移脚本：backend/migrate_add_user_id_to_mqtt_configs.py
```

#### 步骤2：为主题配置表添加user_id字段
```python
# 创建迁移脚本：backend/migrate_add_user_id_to_topic_configs.py
```

#### 步骤3：数据迁移
- 将现有的MQTT配置和主题配置标记为"系统级"（user_id=NULL）
- 或者分配给创建者（如果有记录）

### 3.2 模型层改造

#### 3.2.1 更新MQTTConfigModel
```python
# backend/models/mqtt_config.py
user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
user = relationship("UserModel", back_populates="mqtt_configs")
```

#### 3.2.2 更新TopicConfigModel
```python
# backend/models/topic_config.py
user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
user = relationship("UserModel", back_populates="topic_configs")
```

#### 3.2.3 更新UserModel
```python
# backend/models/user.py
mqtt_configs = relationship("MQTTConfigModel", back_populates="user")
topic_configs = relationship("TopicConfigModel", back_populates="user")
```

### 3.3 服务层改造

#### 3.3.1 MQTT配置服务 (`mqtt_config_service.py`)
需要修改所有查询函数，添加用户过滤：
```python
def get_mqtt_configs(db: Session, skip: int = 0, limit: int = 100, user_id: Optional[int] = None):
    query = db.query(MQTTConfigModel)
    if user_id is not None:
        query = query.filter(MQTTConfigModel.user_id == user_id)
    return query.offset(skip).limit(limit).all()

def create_mqtt_config(db: Session, config: MQTTConfigCreate, user_id: Optional[int] = None):
    config_data = config.model_dump()
    if user_id:
        config_data["user_id"] = user_id
    # ...
```

#### 3.3.2 主题配置服务 (`topic_config_service.py`)
同样需要添加用户过滤逻辑。

#### 3.3.3 MQTT服务改造 (`mqtt_service.py`)
这是最复杂的部分，需要实现：

**方案A实现（每个用户独立连接）**：
```python
class UserMQTTService:
    """用户级MQTT服务"""
    def __init__(self, user_id: int):
        self.user_id = user_id
        self.client: Optional[mqtt.Client] = None
        self.is_connected = False
    
    def init_mqtt_client(self, mqtt_config: MQTTConfigModel):
        # 使用用户特定的MQTT配置初始化连接
        pass
    
    def subscribe_to_user_topics(self):
        # 只订阅该用户的主题配置
        pass

# 全局管理器
class MQTTServiceManager:
    """MQTT服务管理器，管理所有用户的MQTT连接"""
    def __init__(self):
        self.user_services: Dict[int, UserMQTTService] = {}
    
    def get_or_create_service(self, user_id: int) -> UserMQTTService:
        if user_id not in self.user_services:
            self.user_services[user_id] = UserMQTTService(user_id)
        return self.user_services[user_id]
```

**方案B实现（连接池）**：
```python
class MQTTConnectionPool:
    """MQTT连接池"""
    def __init__(self, max_connections: int = 10):
        self.pool: List[mqtt.Client] = []
        self.user_connections: Dict[int, mqtt.Client] = {}
        self.max_connections = max_connections
    
    def get_connection_for_user(self, user_id: int, mqtt_config: MQTTConfigModel):
        # 复用连接或创建新连接
        pass
```

### 3.4 API层改造

#### 3.4.1 MQTT配置API (`api/mqtt_configs.py`)
需要修改所有端点：

```python
@router.get("", response_model=List[MQTTConfig])
def get_mqtt_configs(
    skip: int = 0, 
    limit: int = 100, 
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """获取MQTT配置列表"""
    user_id = None if current_user.is_admin else current_user.id
    return mqtt_config_service_module.get_mqtt_configs(
        db, skip=skip, limit=limit, user_id=user_id
    )

@router.post("", response_model=MQTTConfig, status_code=status.HTTP_201_CREATED)
def create_mqtt_config(
    config: MQTTConfigCreate, 
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """创建MQTT配置"""
    # 普通用户只能为自己创建，管理员可以创建全局配置（user_id=None）
    user_id = None if current_user.is_admin and config.is_global else current_user.id
    return mqtt_config_service_module.create_mqtt_config(db, config, user_id=user_id)
```

#### 3.4.2 主题配置API (`api/topic_configs.py`)
同样的改造逻辑。

#### 3.4.3 设备API (`api/devices.py`)
✅ 已有用户隔离，但需要确保设备创建时关联正确的用户。

### 3.5 前端改造

#### 3.5.1 权限控制
- 普通用户：只能看到自己的MQTT配置、主题配置、设备
- 管理员：可以看到所有资源，并有"全局配置"选项

#### 3.5.2 UI改进
- 在配置列表页面显示"我的配置"和"全局配置"（管理员）
- 添加用户标识，明确显示配置的归属

## 四、安全性考虑

### 4.1 主题访问控制
- **建议**：在MQTT Broker（如EMQX）层面配置ACL规则
- **规则示例**：
  ```
  用户1只能订阅：user/1/#
  用户1只能发布到：user/1/device/+/control
  ```

### 4.2 API权限验证
- ✅ 已有基本的权限检查
- **增强**：确保所有资源访问都验证 `user_id` 匹配

### 4.3 数据隔离验证
- 在服务层添加数据隔离检查
- 防止用户通过修改请求参数访问其他用户的资源

## 五、性能优化建议

### 5.1 数据库索引
```sql
CREATE INDEX idx_mqtt_configs_user_id ON mqtt_configs(user_id);
CREATE INDEX idx_topic_configs_user_id ON topic_configs(user_id);
CREATE INDEX idx_devices_user_id ON devices(user_id);
```

### 5.2 连接管理
- 实现连接池，避免频繁创建/销毁连接
- 实现连接心跳检测，自动重连
- 实现连接数限制，防止资源耗尽

### 5.3 缓存策略
- 缓存用户的MQTT配置和主题配置
- 使用Redis缓存活跃连接状态

## 六、测试建议

### 6.1 单元测试
- 测试用户隔离：确保用户A无法访问用户B的资源
- 测试管理员权限：确保管理员可以访问所有资源
- 测试MQTT连接隔离：确保不同用户的连接互不干扰

### 6.2 集成测试
- 测试多用户同时创建配置
- 测试多用户同时订阅主题
- 测试主题消息隔离

### 6.3 压力测试
- 测试多用户并发连接
- 测试大量主题订阅的性能
- 测试连接池的容量限制

## 七、迁移计划

### 阶段1：数据模型改造（1-2天）
1. 创建数据库迁移脚本
2. 更新模型定义
3. 运行迁移并验证

### 阶段2：服务层改造（2-3天）
1. 更新MQTT配置服务
2. 更新主题配置服务
3. 改造MQTT服务（选择方案A或B）

### 阶段3：API层改造（1-2天）
1. 更新所有API端点
2. 添加权限验证
3. 更新API文档

### 阶段4：前端改造（2-3天）
1. 更新UI以支持用户隔离
2. 添加权限控制
3. 更新用户体验

### 阶段5：测试和优化（2-3天）
1. 全面测试
2. 性能优化
3. 文档更新

**总计**：约8-13个工作日

## 八、注意事项

### 8.1 向后兼容
- 保持现有API的兼容性
- 为旧数据提供迁移路径
- 支持渐进式迁移

### 8.2 错误处理
- 用户删除时，需要处理其MQTT连接和配置
- 配置删除时，需要处理关联的设备
- 连接失败时的重试机制

### 8.3 监控和日志
- 记录每个用户的操作日志
- 监控MQTT连接状态
- 监控资源使用情况

## 九、扩展功能建议

### 9.1 用户配额管理
- 限制每个用户的设备数量
- 限制每个用户的MQTT配置数量
- 限制每个用户的主题订阅数量

### 9.2 组织/团队功能
- 支持用户分组（组织）
- 支持组织内资源共享
- 支持组织管理员

### 9.3 审计日志
- 记录所有资源创建/修改/删除操作
- 记录MQTT连接和订阅操作
- 提供审计日志查询接口

## 十、总结

多租户功能的核心是**数据隔离**和**资源独立**。实现时需要：

1. ✅ **数据层**：添加 `user_id` 字段，建立用户-资源关联
2. ✅ **服务层**：所有查询添加用户过滤，确保数据隔离
3. ✅ **API层**：权限验证，确保用户只能访问自己的资源
4. ✅ **MQTT层**：实现连接隔离或主题隔离
5. ✅ **前端层**：UI支持用户隔离，清晰的权限展示

建议优先实现**方案A（每个用户独立连接）**，因为：
- 实现相对简单
- 隔离性最好
- 适合中小规模用户
- 后续可以升级到方案B

如果用户规模较大（>100），建议直接实现**方案B（连接池）**。
